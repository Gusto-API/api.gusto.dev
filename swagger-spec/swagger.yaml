swagger: '2.0'
info:
  title: Gusto API Documentation
  version: '1.0'
  description: >-

    ## A Developer’s Best Friend

    Welcome to Gusto’s API documentation. This site serves as both a technical reference for the endpoints available and a general overview of payroll. We designed the objects and their properties to require as little domain-specific payroll knowledge as possible.

    ### Getting Started

    Gusto has a closed API system and a full near-term roadmap.  We do occasionally support new integrations for products that could potentially benefit many or all of our small businesses.  If you’d like to be considered for a future integration partnership, please email partnerships@gusto.com.


    Existing partners have been given API credentials. These include the application id and secret necessary to interact with any part of the Gusto API. Next, you’ll want to successfully authenticate a user using OAuth. The Authentication section has everything you need to get started.

    ### Payroll Basics

    Payroll in its entirety is rather complex, but the API is designed to shield as much complexity as possible from the end user, without sacrificing functionality. This section gives a birds-eye view of the objects that make up the Gusto system.


    Starting with an authenticated user, you will notice that they may be administrators for multiple companies. This is not uncommon, and your application should prepare for it. Accountants use Gusto to manage payroll for many companies simultaneously.


    <img class="basics" src="/images/authenticated-user-company.svg">


    Companies themselves are, naturally, a collection of one to hundreds of employees. Employee data, on the payroll side, is relatively static. Compensation information, addresses, and tax information changes rather infrequently once set.


    Companies can have multiple work locations, across multiple states, but everyone gets paid at the same time.


    <img class="basics" src="/images/company-to-employees.svg" class="img-fluid">


    Pay periods are the combination of a company, a subset of its employees, and a time range. Not every employee at a company will be a part of every payroll. One-off (or 'off-cycle') payrolls are run for special events such as hiring or termination, and employees can be excluded from payrolls.


    Regular payrolls are tied to a specific pay periods, and all associated information - vacation & sick time, hours worked, bonuses, etc. - should be applied to that time range.


    <img class="basics" src="/images/pay-periods.svg" class="margin-top-50px margin-bottom-50px img-fluid">


    By using the Gusto API, you are agreeing to the following [terms and conditions](https://gusto.com/about/terms).
  x-logo:
    url: '/images/logo-gusto-guava.svg'
    backgroundColor: 'transparent'
host: 'api.gusto.com'
schemes:
  - https
basePath: /v1
x-tagGroups:
  - name: Introduction
    tags:
      - Authentication
      - Versioning
      - Syncing Employees
  - name: Examples
    tags:
      - Updating Payrolls
  - name: API Reference
    tags:
      - Companies
      - Employees
      - Jobs
      - Time Off Requests
      - States

tags:
  - name: Authentication
    x-traitTag: true
    description: >-
      ##  Safety First!

      Due to the sensitive nature of payroll, all potential integrations must be vetted and approved by Gusto.

      ## OAuth

      ### Getting Started

      Authentication is done using [OAuth2](http://oauth.net/2/). Numerous libraries implementing the protocol can be found on the [OAuth2 homepage](http://oauth.net/2/).

      Should you choose to implement your own flow, or if you just want to know more about what goes on behind the scenes, we'll walk through the basics of authenticating with Gusto via OAuth. It can be a bit tricky - even with a library - so if you have questions at any point, please send us an email.

      Outline:

      - Direct user to authorize
      - User authorizes application to access their information
      - User redirected to partner site with authorization code
      - Exchange authorization code for access/refresh token pair
      - Make requests, always including the access token parameter
      - Exchange refresh token for new access/refresh tokens

      Here is the sample application information we'll use throughout:

      ```
        id:           bbb286ff1a4fe6b84742b0d49b8d0d65bd0208d27d3d50333591df71c45da519
        secret:       cb06cb755b868a819ead51671f0f7e9c35c7c4cbbae0e38bef167e0e4ba64ee6
        redirect_url: https://example.com/callback
      ```

      ### Authorization Code

      > **Expiration Time:** 10 minutes
      >
      > **HTTP Method:** GET
      >
      > **URL:** https://api.gusto.com/oauth/authorize
      >
      > **Parameters:**
      >
      > - `client_id` your client id
      > - `redirect_uri` [percent-encoded](http://en.wikipedia.org/wiki/Percent-encoding/) url you submitted when signing up > for the Gusto API. Should the user accept integration, the user will be returned to this url with the `code` parameter set to the authorization > code.
      > - `response_type` the literal string `code`


      The first step is a user authorizing your application to access their information on Gusto. To do this, you'll create a link to Gusto where they can approve access.

      The link contains the parameters outlined above. For this sample application, the link would look something like this:

      ```html
        <a href="https://api.gusto.com/oauth/authorize?client_id=bbb286ff1a4fe6b84742b0d49b8d0d65bd0208d27d3d50333591df71c45da519&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&response_type=code">Authorize with Gusto</a>
      ```

      On Gusto, the user will be prompted to log in to their Gusto account and authorize integration with your application for one or more of their companies.

      After accepting, Gusto will generate an authorization code and the user will be redirected to the redirect_uri with that code attached. In this case, the user will be sent to a url like this:

      ```
      https://example.com/callback?code=51d5d63ae28783aecd59e7834be2c637a9ee260f241b191565aa10fe380471db
      ```

      This parameter contains the authorization code that you will then use to obtain your first access token.

      ### Access Token

      > **Expiration Time:** 2 hours.
      >
      > **HTTP Method:** POST
      >
      > **URL:** https://api.gusto.com/oauth/token
      >
      > **Parameters:**
      >
      > - `client_id` - your client id
      > - `client_secret` - your client secret
      > - `redirect_uri` - the [percent-encoded](http://en.wikipedia.org/wiki/Percent-encoding/) url you submitted when signing up for the Gusto API.
      > - `code` - the code being exchanged for an access token. This should be the Authorization Code received above (`51d5d63ae28783aecd59e7834be2c637a9ee260f241b191565aa10fe380471db`.)
      > - `grant_type` - this should be the literal string "authorization_code"

      Next, you will make a server-side request to Gusto with your authorization code to `https://api.gusto.com/oauth/token` with the parameters outlined above. In this case, the request would look like this:

      ```
      https://api.gusto.com/oauth/token?client_id=bbb286ff1a4fe6b84742b0d49b8d0d65bd0208d27d3d50333591df71c45da519&client_secret=cb06cb755b868a819ead51671f0f7e9c35c7c4cbbae0e38bef167e0e4ba64ee6&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&code=51d5d63ae28783aecd59e7834be2c637a9ee260f241b191565aa10fe380471db&grant_type=authorization_code
      ```

      That's a lot of information.

      The `client_id`, `client_secret`, and `redirect_uri` are used to identify your application. We ensure that not only is it a valid application requesting a token, but also that it is the same application to which the included `code` was granted. The `code` matches the application to the user and the `grant_type` tells us what type of code is included.

      Upon successful authentication, the response will look like this:

      ```json
      {
        "access_token": "de6780bc506a0446309bd9362820ba8aed28aa506c71eedbe1c5c4f9dd350e54",
        "token_type": "bearer",
        "expires_in": 7200,
        "refresh_token": "8257e65c97202ed1726cf9571600918f3bffb2544b26e00a61df9897668c33a1"
      }
      ```

      The `access_token` should be included in the `Authorization` HTTP header with every call to the API. Failure to include the `access_token` or using an expired token will result in a 401 response. For example, to use the above token in a subsequent request, include the following in the request's HTTP headers:

      ```
      Authorization: Bearer de6780bc506a0446309bd9362820ba8aed28aa506c71eedbe1c5c4f9dd350e54
      ```

      ### Refresh Token

      > **Expiration Time:** Never (invalid after one use)
      >
      > **HTTP Method** POST
      >
      > **URL** https://api.gusto.com/oauth/token
      >
      > **Parameters:**
      >
      > - `client_id` your client id
      > - `client_secret` your client secret
      > - `redirect_uri` the percent-encoded url you submitted when signing up for the Gusto API.
      > - `refresh_token` the refresh_token being exchanged for an access token code.
      > - `grant_type` this should be the literal string 'refresh_token'

      Access tokens expire 2 hours after they are issued.

      You may exchange your refresh token for a new access token once, making a request very similar to exchanging authorization code for an access token.

      The only difference is that `code` is now `refresh_token` and `grant_type` is set to "refresh_token". Assuming you are refreshing the access token received in the previous section, here is the request you would make:

      ```
      https://api.gusto.com/oauth/token?client_id=bbb286ff1a4fe6b84742b0d49b8d0d65bd0208d27d3d50333591df71c45da519&client_secret=cb06cb755b868a819ead51671f0f7e9c35c7c4cbbae0e38bef167e0e4ba64ee6&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&refresh_token=8257e65c97202ed1726cf9571600918f3bffb2544b26e00a61df9897668c33a1&grant_type=refresh_token
      ```

      The corresponding response, including both a fresh access token and a new refresh token, will look something like this:

      ```json
      {
        "access_token": "de6780bc506a0446309bd9362820ba8aed28aa506c71eedbe1c5c4f9dd350e54",
        "token_type": "bearer",
        "expires_in": 7200,
        "refresh_token": "8257e65c97202ed1726cf9571600918f3bffb2544b26e00a61df9897668c33a1"
      }
      ```


      ## API Token Authentication

      There are certain endpoints that involve the application acting on behalf of
      itself rather than a Gusto user. For these, certified partners are granted
      an API token. This token is included in the authorization HTTP header with the
      `Token` scheme.

      ### Example

      **HTTP Headers**

      ```
      Content-Type: application/json
      Authorization: Token bbb286ff1a4fe6b84742b0d49b8d0d65bd0208d27d3d50333591df71c45da519
      ```
  - name: Versioning
    x-traitTag: true
    description: >-
      ## Building for the Future

      Versions are essentially snapshots of a given resource. If things change, we want you to find out immediately. We’d rather an extra HTTP request or 2 than employees receiving incorrect pay.

      ### API Layer

      The Gusto API itself is versioned directly in the url - `/:version_string` - to allow for backwards compatibility. We guarantee that an application built with v1 of the API will always work, without changes, as long as that API version is supported. If we would like to implement breaking changes into the API, like changing request or response signatures, we will create a separate version of the API for new applications while supporting existing applications using our previous version.


      In essence, this means changes will only be additive. A given version of the API will always provide as much or more information than when you first implement the integration.

      ### Object Layer

      #### Idempotency

      Requests are [idempotent](http://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning) such that 50 identical requests will only update the data once. This applies both to retrieving information (via GET requests) as well as updating information in the Gusto ecosystem (via POST requests.)


      In practice, this allows you to try identical requests multiple times without fear that data will be altered multiple times. This also means that any updates will overwrite the existing data, instead of allowing additive or incremental changes.


      Idempotency is wonderful for ensuring request safety, but in order for updates to be idempotent, they must overwrite the existing data. But what if the data in Gusto has changed since you last requested it? Can you end up overwriting changes made by the other applications or the user?

      #### Example

      For example, let’s say you wish to give Frank (with id 7) a $200 bonus for the current pay period. Unbeknownst to you, another application has already given Frank a $150 bonus. You make a request to the 'Update Payroll' endpoint with a bonus of "200.00".


      Your request overwrites any bonus ($150) already in our system for employee 7 for the Feb 1 - 15 pay period.


      Frank is now scheduled to receive a bonus of $200, which is $150 less than the combined value of the individual bonuses. While this may be good news for Accounting, it is obviously unacceptable.


      This is why versioning extends to the object level. Objects returned from the Gusto API include a `version` field that denotes which version of the object you hold. This version is calculated based on all updatable attributes of this and child objects.


      When updating an object, you must include this `version` field because it tells us how recently you have pulled information. If the data has changed since the last time you made a request, we will respond with the HTTP status code 409 Conflict. The client should request an updated version of the resource - which will include an updated `version` - and make a request with the updated information.


      **Note**: Since versions are only updated when attributes that are updatable change (as opposed to any data returned by the API), they should not be relied on to monitor any change in the Gusto database. Their design is centered around preventing race conditions and overwriting data that the request couldn't have known has changed.

  - name: Syncing Employees
    x-traitTag: true
    description: >-
      ## Are We Talking About The Same People?

      You have successfully <a href="/v1/examples/authentication">integrated with OAuth</a>, gotten back the authenticated
      companies for the <a href="/v1/current_user">current user</a>, and fetched the
      <a href="/v1/companies">company information</a>.


      Now you have the JSON representation of 20 employees and need to map them to the employees in your database.


      Naturally, the approach you'll choose will depend on the information you have available. Here are some suggestions for
      matching up the employees in your database with the ones in ours. We recommend persisting the unique `id` attribute
      that is returned by the Api, rather than redoing the match at the beginning of a pay period.

      ### Email Addresses

      We provided email addresses with employee information specifically for matching employees between systems. For just
      under 75% companies on Gusto, every single employee has an email address available.


      This assumes that employees provide the same email address to both systems, but for work applications this is by far
      the norm.

      ### Date of Birth

      Almost 98% of employees in the Gusto system have birthdays associated with them. Of those that do, ~81% have a
      unique birthday (comprised of year, month, and day).


      Be careful when only comparing month and day, as it takes
      [only 57 people](http://en.wikipedia.org/wiki/Birthday_problem) to achieve a 99% probability of collision.

      ### Full Name

      First and last name are required for employees in the Gusto system. Additionally, ~55% provide middle initials.
      If you can find an exact match based on full-name, then you're finished.


      Typos do happen, in which case checking the [Hamming Distance](http://en.wikipedia.org/wiki/Hamming_distance) can be
      helpful. If you have one unmatched set of employees with a Hamming Distance of 1, for example, it is pretty likely that
      they are the same person.

  - name: Updating Payrolls
    x-traitTag: true
    description: >-
      updating payroll example

produces:
  - application/json

paths:

  /companies/{company_id}/employees:
    $ref: 'employees/list.yaml'

  /companies/{company_id}/locations:
    $ref: 'company_locations/list.yaml'

  /companies/{company_id}/time_off_requests:
    $ref: 'time_off_requests/list.yaml'

  /companies/{company_id}/time_off_requests/{time_off_request_id}:
    $ref: 'time_off_requests/detail.yaml'

  /employees/{employee_id}:
    $ref: 'employees/detail.yaml'

  /employees/{employee_id}/home_address:
    $ref: 'employee_home_address/detail.yaml'

  /employees/{employee_id}/jobs:
    $ref: 'jobs/list.yaml'

  /jobs/{job_id}:
    $ref: 'jobs/detail.yaml'

  /states:
    $ref: 'states/detail.yaml'
